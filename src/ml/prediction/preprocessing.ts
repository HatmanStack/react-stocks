/**
 * Feature Engineering and Preprocessing
 *
 * Functions for converting raw stock data into feature matrices
 * and labels for logistic regression training.
 */

import type { PredictionInput, FeatureMatrix, Labels } from './types';

/**
 * One-hot encode sentiment categories
 *
 * @param sentiment - Array of sentiment strings ("POS", "NEG", "NEUT", or others)
 * @returns 2D array with 4 columns: [is_pos, is_neg, is_neut, is_unknown]
 */
export function oneHotEncode(sentiment: string[]): number[][] {
  const encoded: number[][] = [];

  for (const s of sentiment) {
    const normalized = s ? s.toUpperCase().trim() : 'UNKNOWN';

    if (normalized === 'POS') {
      encoded.push([1, 0, 0, 0]); // is_pos=1
    } else if (normalized === 'NEG') {
      encoded.push([0, 1, 0, 0]); // is_neg=1
    } else if (normalized === 'NEUT' || normalized === 'NEUTRAL') {
      encoded.push([0, 0, 1, 0]); // is_neut=1
    } else {
      encoded.push([0, 0, 0, 1]); // is_unknown=1
    }
  }

  return encoded;
}

/**
 * Build feature matrix from raw prediction inputs
 *
 * Creates 8-feature matrix:
 * [close, volume, positive, negative, is_pos, is_neg, is_neut, is_unknown]
 *
 * @param input - Raw prediction input data
 * @returns Feature matrix (n_samples Ã— 8)
 * @throws Error if input arrays have inconsistent lengths
 */
export function buildFeatureMatrix(input: PredictionInput): FeatureMatrix {
  const { close, volume, positive, negative, sentiment } = input;

  // Validate input lengths
  const n = close.length;
  if (
    volume.length !== n ||
    positive.length !== n ||
    negative.length !== n ||
    sentiment.length !== n
  ) {
    throw new Error(
      `Preprocessing: Inconsistent input lengths. ` +
        `close=${close.length}, volume=${volume.length}, ` +
        `positive=${positive.length}, negative=${negative.length}, ` +
        `sentiment=${sentiment.length}`
    );
  }

  if (n === 0) {
    return [];
  }

  // One-hot encode sentiment
  const oneHot = oneHotEncode(sentiment);

  // Build feature matrix
  const features: FeatureMatrix = new Array(n);
  for (let i = 0; i < n; i++) {
    features[i] = [
      close[i],
      volume[i],
      positive[i],
      negative[i],
      ...oneHot[i], // is_pos, is_neg, is_neut, is_unknown
    ];
  }

  return features;
}

/**
 * Create binary labels for prediction
 *
 * Labels are generated by comparing current price to future price:
 * - 0 if price rises (close[i] <= close[i + horizon])
 * - 1 if price drops (close[i] > close[i + horizon])
 *
 * @param close - Array of closing prices
 * @param horizon - Number of periods ahead to compare (1=next day, 10=2 weeks, 21=1 month)
 * @returns Binary labels (0 or 1) with length = close.length - horizon
 */
export function createLabels(close: number[], horizon: number): Labels {
  if (horizon < 1) {
    throw new Error(`Preprocessing: horizon must be >= 1, got ${horizon}`);
  }

  if (close.length <= horizon) {
    return []; // Not enough data to create any labels
  }

  const labels: Labels = [];

  for (let i = 0; i < close.length - horizon; i++) {
    // Label = 1 if price will drop, 0 if price will rise/stay
    const label = close[i] > close[i + horizon] ? 1 : 0;
    labels.push(label);
  }

  return labels;
}

/**
 * Get the number of features in the feature matrix
 */
export const FEATURE_COUNT = 8;

/**
 * Get feature names in order
 */
export const FEATURE_NAMES = [
  'close',
  'volume',
  'positive',
  'negative',
  'is_pos',
  'is_neg',
  'is_neut',
  'is_unknown',
] as const;

/**
 * Validate feature matrix shape
 *
 * @param X - Feature matrix
 * @throws Error if shape is invalid
 */
export function validateFeatureMatrix(X: FeatureMatrix): void {
  if (!X || X.length === 0) {
    throw new Error('Preprocessing: Feature matrix cannot be empty');
  }

  const nFeatures = X[0].length;
  if (nFeatures !== FEATURE_COUNT) {
    throw new Error(
      `Preprocessing: Expected ${FEATURE_COUNT} features, got ${nFeatures}`
    );
  }

  // Check all rows have same number of features
  for (let i = 1; i < X.length; i++) {
    if (X[i].length !== nFeatures) {
      throw new Error(
        `Preprocessing: Inconsistent feature count at row ${i}. ` +
          `Expected ${nFeatures}, got ${X[i].length}`
      );
    }
  }

  // Check for non-finite values
  for (let i = 0; i < X.length; i++) {
    for (let j = 0; j < nFeatures; j++) {
      if (!isFinite(X[i][j])) {
        throw new Error(
          `Preprocessing: Non-finite value at row ${i}, column ${j}: ${X[i][j]}`
        );
      }
    }
  }
}

/**
 * Validate labels
 *
 * @param y - Label array
 * @throws Error if labels are invalid
 */
export function validateLabels(y: Labels): void {
  if (!y || y.length === 0) {
    throw new Error('Preprocessing: Labels cannot be empty');
  }

  for (let i = 0; i < y.length; i++) {
    if (y[i] !== 0 && y[i] !== 1) {
      throw new Error(
        `Preprocessing: Invalid label at index ${i}. ` +
          `Expected 0 or 1, got ${y[i]}`
      );
    }
  }
}
